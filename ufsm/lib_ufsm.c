#include "lua.h"
#include "lauxlib.h"

static const char* lua_m_ufsm =
"local ffi = require('ffi')\n"
"\n"
"ffi.cdef[[\n"
"\n"
"enum ufsm_status_codes\n"
"{\n"
"    UFSM_OK,\n"
"    UFSM_ERROR,\n"
"    UFSM_ERROR_NO_INIT_REGION,\n"
"    UFSM_ERROR_UNKNOWN_STATE_KIND,\n"
"    UFSM_ERROR_EVENT_NOT_PROCESSED,\n"
"    UFSM_ERROR_LCA_NOT_FOUND,\n"
"    UFSM_ERROR_STACK_OVERFLOW,\n"
"    UFSM_ERROR_STACK_UNDERFLOW,\n"
"    UFSM_ERROR_QUEUE_EMPTY,\n"
"    UFSM_ERROR_QUEUE_FULL,\n"
"    UFSM_ERROR_MACHINE_TERMINATED,\n"
"};\n"
"\n"
"typedef enum ufsm_status_codes ufsm_status_t;\n"
"\n"
"enum ufsm_transition_kind\n"
"{\n"
"    UFSM_TRANSITION_EXTERNAL,\n"
"    UFSM_TRANSITION_INTERNAL,\n"
"    UFSM_TRANSITION_LOCAL,\n"
"};\n"
"\n"
"enum ufsm_state_kind\n"
"{\n"
"    UFSM_STATE_SIMPLE,\n"
"    UFSM_STATE_INIT,\n"
"    UFSM_STATE_FINAL,\n"
"    UFSM_STATE_SHALLOW_HISTORY,\n"
"    UFSM_STATE_DEEP_HISTORY,\n"
"    UFSM_STATE_EXIT_POINT,\n"
"    UFSM_STATE_ENTRY_POINT,\n"
"    UFSM_STATE_JOIN,\n"
"    UFSM_STATE_FORK,\n"
"    UFSM_STATE_CHOICE,\n"
"    UFSM_STATE_JUNCTION,\n"
"    UFSM_STATE_TERMINATE,\n"
"};\n"
"\n"
"typedef bool (*ufsm_guard_func_t) (struct ufsm_context* machine_context, struct ufsm_context* state_context, struct ufsm_context* event_context);\n"
"typedef void (*ufsm_action_func_t) (struct ufsm_context* machine_context, struct ufsm_context* event_context);\n"
"typedef void (*ufsm_entry_exit_func_t) (struct ufsm_context* machine_context, struct ufsm_context* state_context, struct ufsm_context* event_context);\n"
"typedef void (*ufsm_queue_cb_t) (void);\n"
"typedef ufsm_status_t(*ufsm_doact_cb_t) (struct ufsm_machine *m, struct ufsm_state *s);\n"
"typedef void (*ufsm_doact_func_t) (struct ufsm_context* machine_context, struct ufsm_context* state_context, struct ufsm_context* event_context,\n"
"                                   ufsm_doact_cb_t cb);\n"
"\n"
"typedef void (*ufsm_debug_event_t) (uint32_t ev);\n"
"typedef void (*ufsm_debug_transition_t) (struct ufsm_transition *t);\n"
"typedef void (*ufsm_debug_enter_region_t) (struct ufsm_region *region);\n"
"typedef void (*ufsm_debug_leave_region_t) (struct ufsm_region *region);\n"
"typedef void (*ufsm_debug_guard_t) (struct ufsm_guard *guard, bool result);\n"
"typedef void (*ufsm_debug_action_t) (struct ufsm_action *action);\n"
"typedef void (*ufsm_debug_enter_state_t) (struct ufsm_state *s);\n"
"typedef void (*ufsm_debug_exit_state_t) (struct ufsm_state *s);\n"
"typedef void (*ufsm_debug_entry_exit_t) (struct ufsm_entry_exit *f);\n"
"typedef void (*ufsm_debug_reset_t) (struct ufsm_machine *m);\n"
"\n"
"struct ufsm_context{\n"
"	int id;\n"
"} ;\n"
"\n"
"struct ufsm_stack\n"
"{\n"
"    uint32_t no_of_elements;\n"
"    void **data;\n"
"    uint32_t pos;\n"
"};\n"
"\n"
"struct ufsm_queue\n"
"{\n"
"    uint32_t no_of_elements;\n"
"    uint32_t s;\n"
"    uint32_t head;\n"
"    uint32_t tail;\n"
"    uint32_t *data;\n"
"    ufsm_queue_cb_t on_data;\n"
"    ufsm_queue_cb_t lock;\n"
"    ufsm_queue_cb_t unlock;\n"
"};\n"
"\n"
"struct ufsm_machine\n"
"{\n"
"    const char *id;\n"
"    const char *name;\n"
"    ufsm_debug_event_t debug_event;\n"
"    ufsm_debug_transition_t debug_transition;\n"
"    ufsm_debug_enter_region_t debug_enter_region;\n"
"    ufsm_debug_leave_region_t debug_leave_region;\n"
"    ufsm_debug_guard_t debug_guard;\n"
"    ufsm_debug_action_t debug_action;\n"
"    ufsm_debug_enter_state_t debug_enter_state;\n"
"    ufsm_debug_exit_state_t debug_exit_state;\n"
"    ufsm_debug_reset_t debug_reset;\n"
"    ufsm_debug_entry_exit_t debug_entry_exit;\n"
"    bool terminated;\n"
"    void *stack_data[128];\n"
"    void *stack_data2[128];\n"
"    void *completion_stack_data[16];\n"
"    uint32_t queue_data[16];\n"
"    uint32_t defer_queue_data[16];\n"
"    struct ufsm_queue queue;\n"
"    struct ufsm_queue defer_queue;\n"
"    struct ufsm_state *parent_state;\n"
"    struct ufsm_stack stack;\n"
"    struct ufsm_stack stack2;\n"
"    struct ufsm_stack completion_stack;\n"
"    struct ufsm_region *region;\n"
"	void *context;\n"
"    struct ufsm_machine *next;\n"
"};\n"
"\n"
"struct ufsm_action\n"
"{\n"
"    const char *id;\n"
"    const char *name;\n"
"    ufsm_action_func_t f;\n"
"    struct ufsm_action *next;\n"
"};\n"
"\n"
"struct ufsm_guard\n"
"{\n"
"    const char *id;\n"
"    const char *name;\n"
"    ufsm_guard_func_t f;\n"
"    struct ufsm_guard *next;\n"
"};\n"
"\n"
"struct ufsm_entry_exit\n"
"{\n"
"    const char *id;\n"
"    const char *name;\n"
"    ufsm_entry_exit_func_t f;\n"
"    struct ufsm_entry_exit *next;\n"
"};\n"
"\n"
"struct ufsm_doact\n"
"{\n"
"    const char *id;\n"
"    const char *name;\n"
"    ufsm_doact_func_t f_start;\n"
"    ufsm_entry_exit_func_t f_stop;\n"
"    struct ufsm_doact *next;\n"
"};\n"
"\n"
"struct ufsm_trigger\n"
"{\n"
"    const char *name;\n"
"    uint32_t trigger;\n"
"    struct ufsm_trigger *next;\n"
"};\n"
"\n"
"struct ufsm_transition\n"
"{\n"
"    const char *id;\n"
"    const char *name;\n"
"    bool defer;\n"
"    enum ufsm_transition_kind kind;\n"
"    struct ufsm_trigger *trigger;\n"
"    struct ufsm_action *action;\n"
"    struct ufsm_guard *guard;\n"
"    struct ufsm_state *source;\n"
"    struct ufsm_state *dest;\n"
"    struct ufsm_transition *next;\n"
"};\n"
"\n"
"struct ufsm_region\n"
"{\n"
"    const char *id;\n"
"    const char *name;\n"
"    bool has_history;\n"
"    struct ufsm_state *current;\n"
"    struct ufsm_state *history;\n"
"    struct ufsm_state *state;\n"
"    struct ufsm_transition *transition;\n"
"    struct ufsm_state *parent_state;\n"
"    struct ufsm_region *next;\n"
"};\n"
"\n"
"struct ufsm_state\n"
"{\n"
"    const char *id;\n"
"    const char *name;\n"
"    bool cant_exit;\n"
"    enum ufsm_state_kind kind;\n"
"    struct ufsm_entry_exit *entry;\n"
"    struct ufsm_doact *doact;\n"
"    struct ufsm_entry_exit *exit;\n"
"    struct ufsm_region *region;\n"
"    struct ufsm_region *parent_region;\n"
"    struct ufsm_machine *submachine;\n"
"	void *context;\n"
"    struct ufsm_state *next;\n"
"};\n"
"\n"
"ufsm_status_t ufsm_init_machine(struct ufsm_machine *m);\n"
"ufsm_status_t ufsm_process(struct ufsm_machine *m, int32_t ev, struct ufsm_context* event_context);\n"
"ufsm_status_t ufsm_process_auto(struct ufsm_machine *m, int32_t ev, struct ufsm_context* event_context);\n"
"\n"
"]]\n"
"\n"
"local ufsm = ffi.C\n"
"return ufsm";

void luaopen_ufsm(lua_State* L)
{
	lua_getglobal(L, "package");
	lua_getfield(L, -1, "preload");
	luaL_loadstring(L, lua_m_ufsm);
	lua_setfield(L, -2, "libufsm");
	lua_pop(L, 2);
}